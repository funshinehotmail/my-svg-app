import pptxgen from 'pptxgenjs';
import type { ContentAnalysis, VisualSuggestion } from '../types';
import type { ThemeId } from '../utils/constants';
import { themes } from '../utils/constants';

export interface ExportOptions {
  title?: string;
  author?: string;
  subject?: string;
  includeNotes?: boolean;
  slideLayout?: 'standard' | 'widescreen';
  quality?: 'standard' | 'high';
}

export interface SlideContent {
  title: string;
  content: string;
  type: 'title' | 'content' | 'chart' | 'image' | 'comparison';
  data?: any;
  imageUrl?: string;
}

export class PowerPointExportService {
  private pptx: pptxgen;
  private theme: any;

  constructor(themeId: ThemeId = 'professional') {
    this.pptx = new pptxgen();
    this.theme = themes.find(t => t.id === themeId) || themes[0];
    this.setupPresentation();
  }

  private setupPresentation() {
    // Set presentation properties
    this.pptx.author = 'VisualAI';
    this.pptx.company = 'VisualAI Platform';
    this.pptx.revision = '1';
    this.pptx.subject = 'AI-Generated Visual Content';
    this.pptx.title = 'Visual Presentation';

    // Set slide size (16:9 widescreen by default)
    this.pptx.defineLayout({ name: 'LAYOUT_16x9', width: 10, height: 5.625 });
    this.pptx.layout = 'LAYOUT_16x9';

    // Define master slide with theme colors
    this.pptx.defineSlideMaster({
      title: 'MASTER_SLIDE',
      background: { color: this.theme.colors.background },
      objects: [
        {
          rect: {
            x: 0, y: 0, w: '100%', h: '100%',
            fill: { color: this.theme.colors.background }
          }
        }
      ]
    });
  }

  public async exportFromAnalysis(
    analysis: ContentAnalysis,
    suggestions: VisualSuggestion[],
    editorContent?: string,
    options: ExportOptions = {}
  ): Promise<void> {
    try {
      // Create title slide
      this.createTitleSlide(options.title || 'AI-Generated Visual Content');

      // Create overview slide
      this.createOverviewSlide(analysis);

      // Create content slides based on suggestions
      for (const suggestion of suggestions.slice(0, 5)) { // Limit to 5 suggestions
        await this.createSuggestionSlide(suggestion, analysis);
      }

      // Create editor content slide if provided
      if (editorContent) {
        this.createEditorContentSlide(editorContent);
      }

      // Create summary slide
      this.createSummarySlide(analysis);

      // Export the presentation
      const fileName = `${options.title || 'visual-content'}-${Date.now()}.pptx`;
      await this.pptx.writeFile({ fileName });

    } catch (error) {
      console.error('PowerPoint export failed:', error);
      throw new Error('Failed to export PowerPoint presentation');
    }
  }

  private createTitleSlide(title: string) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText(title, {
      x: 1, y: 1.5, w: 8, h: 1.5,
      fontSize: 44,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true,
      align: 'center'
    });

    // Subtitle
    slide.addText('Generated by VisualAI Platform', {
      x: 1, y: 3, w: 8, h: 0.8,
      fontSize: 24,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.textSecondary,
      align: 'center'
    });

    // Date
    slide.addText(new Date().toLocaleDateString(), {
      x: 1, y: 4, w: 8, h: 0.5,
      fontSize: 16,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.textSecondary,
      align: 'center'
    });

    // Decorative element
    slide.addShape(this.pptx.ShapeType.rect, {
      x: 4, y: 4.8, w: 2, h: 0.1,
      fill: { color: this.theme.colors.primary }
    });
  }

  private createOverviewSlide(analysis: ContentAnalysis) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText('Content Overview', {
      x: 0.5, y: 0.5, w: 9, h: 0.8,
      fontSize: 32,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true
    });

    // Key Points
    slide.addText('Key Insights:', {
      x: 0.5, y: 1.5, w: 4, h: 0.5,
      fontSize: 20,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      bold: true
    });

    const keyPointsText = analysis.keyPoints
      .slice(0, 4)
      .map((point, index) => `${index + 1}. ${point}`)
      .join('\n');

    slide.addText(keyPointsText, {
      x: 0.5, y: 2, w: 4, h: 2.5,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text,
      bullet: true
    });

    // Analysis Summary
    slide.addText('Analysis Summary:', {
      x: 5, y: 1.5, w: 4, h: 0.5,
      fontSize: 20,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      bold: true
    });

    const summaryText = [
      `Sentiment: ${analysis.sentiment.charAt(0).toUpperCase() + analysis.sentiment.slice(1)}`,
      `Complexity: ${analysis.complexity.charAt(0).toUpperCase() + analysis.complexity.slice(1)}`,
      `Data Points: ${analysis.dataPoints.length}`,
      `Suggested Visuals: ${analysis.suggestedVisualTypes.length}`
    ].join('\n');

    slide.addText(summaryText, {
      x: 5, y: 2, w: 4, h: 2.5,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text,
      bullet: true
    });
  }

  private async createSuggestionSlide(suggestion: VisualSuggestion, analysis: ContentAnalysis) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText(suggestion.title, {
      x: 0.5, y: 0.5, w: 9, h: 0.8,
      fontSize: 28,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true
    });

    // Description
    slide.addText(suggestion.description, {
      x: 0.5, y: 1.3, w: 9, h: 0.6,
      fontSize: 16,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.textSecondary
    });

    // Visual content based on type
    switch (suggestion.type) {
      case 'chart':
        this.addChartToSlide(slide, analysis.dataPoints);
        break;
      case 'diagram':
        this.addDiagramToSlide(slide, analysis.relationships);
        break;
      case 'timeline':
        this.addTimelineToSlide(slide, analysis.keyPoints);
        break;
      case 'comparison':
        this.addComparisonToSlide(slide, analysis.dataPoints);
        break;
      default:
        this.addGenericVisualToSlide(slide, suggestion);
    }

    // Confidence indicator
    slide.addText(`Confidence: ${Math.round(suggestion.confidence * 100)}%`, {
      x: 8, y: 5, w: 1.5, h: 0.3,
      fontSize: 12,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.textSecondary,
      align: 'right'
    });
  }

  private addChartToSlide(slide: any, dataPoints: any[]) {
    if (dataPoints.length === 0) return;

    const chartData = dataPoints
      .filter(dp => dp.type === 'number' || dp.type === 'percentage')
      .slice(0, 6)
      .map(dp => ({
        name: dp.label,
        labels: [dp.label],
        values: [typeof dp.value === 'number' ? dp.value : parseFloat(dp.value.toString()) || 0]
      }));

    if (chartData.length > 0) {
      slide.addChart(this.pptx.ChartType.bar, chartData, {
        x: 1, y: 2.2, w: 8, h: 2.5,
        chartColors: [this.theme.colors.primary, this.theme.colors.secondary, this.theme.colors.accent],
        showTitle: false,
        showLegend: true,
        legendPos: 'b'
      });
    }
  }

  private addDiagramToSlide(slide: any, relationships: any[]) {
    // Create a simple flow diagram
    const boxes = relationships.slice(0, 4).map((rel, index) => ({
      x: 1 + (index % 2) * 4,
      y: 2.5 + Math.floor(index / 2) * 1.5,
      text: rel.from
    }));

    boxes.forEach((box, index) => {
      // Add box
      slide.addShape(this.pptx.ShapeType.rect, {
        x: box.x, y: box.y, w: 3, h: 0.8,
        fill: { color: this.theme.colors.primary },
        line: { color: this.theme.colors.primary, width: 1 }
      });

      // Add text
      slide.addText(box.text, {
        x: box.x, y: box.y, w: 3, h: 0.8,
        fontSize: 14,
        fontFace: this.theme.typography.bodyFont,
        color: 'FFFFFF',
        align: 'center',
        valign: 'middle'
      });

      // Add arrow to next box
      if (index < boxes.length - 1) {
        slide.addShape(this.pptx.ShapeType.rightArrow, {
          x: box.x + 3.2, y: box.y + 0.3, w: 0.6, h: 0.2,
          fill: { color: this.theme.colors.accent }
        });
      }
    });
  }

  private addTimelineToSlide(slide: any, keyPoints: string[]) {
    // Create a horizontal timeline
    const timelineY = 3;
    const stepWidth = 8 / Math.max(keyPoints.length, 1);

    keyPoints.slice(0, 5).forEach((point, index) => {
      const x = 1 + index * stepWidth;

      // Timeline dot
      slide.addShape(this.pptx.ShapeType.ellipse, {
        x: x + stepWidth/2 - 0.1, y: timelineY - 0.1, w: 0.2, h: 0.2,
        fill: { color: this.theme.colors.primary }
      });

      // Timeline line (except for last item)
      if (index < keyPoints.length - 1) {
        slide.addShape(this.pptx.ShapeType.rect, {
          x: x + stepWidth/2 + 0.1, y: timelineY - 0.02, w: stepWidth - 0.2, h: 0.04,
          fill: { color: this.theme.colors.secondary }
        });
      }

      // Point text
      slide.addText(point, {
        x: x, y: timelineY + 0.3, w: stepWidth, h: 1,
        fontSize: 10,
        fontFace: this.theme.typography.bodyFont,
        color: this.theme.colors.text,
        align: 'center',
        wrap: true
      });
    });
  }

  private addComparisonToSlide(slide: any, dataPoints: any[]) {
    const comparePoints = dataPoints.slice(0, 4);
    const colWidth = 8 / Math.max(comparePoints.length, 1);

    comparePoints.forEach((point, index) => {
      const x = 1 + index * colWidth;

      // Header
      slide.addShape(this.pptx.ShapeType.rect, {
        x: x, y: 2.2, w: colWidth - 0.2, h: 0.6,
        fill: { color: this.theme.colors.primary }
      });

      slide.addText(point.label, {
        x: x, y: 2.2, w: colWidth - 0.2, h: 0.6,
        fontSize: 12,
        fontFace: this.theme.typography.bodyFont,
        color: 'FFFFFF',
        align: 'center',
        valign: 'middle',
        bold: true
      });

      // Value
      slide.addShape(this.pptx.ShapeType.rect, {
        x: x, y: 2.8, w: colWidth - 0.2, h: 1.2,
        fill: { color: this.theme.colors.surface },
        line: { color: this.theme.colors.primary, width: 1 }
      });

      slide.addText(point.value.toString(), {
        x: x, y: 2.8, w: colWidth - 0.2, h: 1.2,
        fontSize: 16,
        fontFace: this.theme.typography.bodyFont,
        color: this.theme.colors.text,
        align: 'center',
        valign: 'middle',
        bold: true
      });
    });
  }

  private addGenericVisualToSlide(slide: any, suggestion: VisualSuggestion) {
    // Add a placeholder visual with suggestion details
    slide.addShape(this.pptx.ShapeType.rect, {
      x: 2, y: 2.2, w: 6, h: 2.5,
      fill: { color: this.theme.colors.surface },
      line: { color: this.theme.colors.primary, width: 2, dashType: 'dash' }
    });

    slide.addText(`${suggestion.type.toUpperCase()} VISUALIZATION`, {
      x: 2, y: 2.8, w: 6, h: 0.6,
      fontSize: 18,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      align: 'center',
      bold: true
    });

    slide.addText(suggestion.description, {
      x: 2.5, y: 3.5, w: 5, h: 1,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text,
      align: 'center',
      wrap: true
    });
  }

  private createEditorContentSlide(editorContent: string) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText('Visual Editor Content', {
      x: 0.5, y: 0.5, w: 9, h: 0.8,
      fontSize: 28,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true
    });

    // Convert HTML content to plain text for PowerPoint
    const plainText = editorContent
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ') // Replace non-breaking spaces
      .trim();

    slide.addText(plainText, {
      x: 0.5, y: 1.5, w: 9, h: 3.5,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text,
      wrap: true,
      valign: 'top'
    });
  }

  private createSummarySlide(analysis: ContentAnalysis) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText('Summary & Next Steps', {
      x: 0.5, y: 0.5, w: 9, h: 0.8,
      fontSize: 32,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true
    });

    // Key takeaways
    slide.addText('Key Takeaways:', {
      x: 0.5, y: 1.5, w: 4, h: 0.5,
      fontSize: 20,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      bold: true
    });

    const takeaways = analysis.keyPoints
      .slice(0, 3)
      .map((point, index) => `• ${point}`)
      .join('\n');

    slide.addText(takeaways, {
      x: 0.5, y: 2, w: 4, h: 2,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text
    });

    // Recommendations
    slide.addText('Recommendations:', {
      x: 5, y: 1.5, w: 4, h: 0.5,
      fontSize: 20,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      bold: true
    });

    const recommendations = [
      '• Review and validate data sources',
      '• Consider additional visual formats',
      '• Gather stakeholder feedback',
      '• Plan implementation timeline'
    ].join('\n');

    slide.addText(recommendations, {
      x: 5, y: 2, w: 4, h: 2,
      fontSize: 14,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.text
    });

    // Footer
    slide.addText('Generated by VisualAI Platform', {
      x: 0.5, y: 4.8, w: 9, h: 0.3,
      fontSize: 12,
      fontFace: this.theme.typography.bodyFont,
      color: this.theme.colors.textSecondary,
      align: 'center',
      italic: true
    });
  }

  public async exportCustomSlides(slides: SlideContent[], options: ExportOptions = {}): Promise<void> {
    try {
      // Create title slide
      this.createTitleSlide(options.title || 'Custom Presentation');

      // Create custom slides
      for (const slideContent of slides) {
        await this.createCustomSlide(slideContent);
      }

      // Export the presentation
      const fileName = `${options.title || 'custom-presentation'}-${Date.now()}.pptx`;
      await this.pptx.writeFile({ fileName });

    } catch (error) {
      console.error('Custom PowerPoint export failed:', error);
      throw new Error('Failed to export custom PowerPoint presentation');
    }
  }

  private async createCustomSlide(slideContent: SlideContent) {
    const slide = this.pptx.addSlide({ masterName: 'MASTER_SLIDE' });

    // Title
    slide.addText(slideContent.title, {
      x: 0.5, y: 0.5, w: 9, h: 0.8,
      fontSize: 28,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.text,
      bold: true
    });

    // Content based on type
    switch (slideContent.type) {
      case 'title':
        slide.addText(slideContent.content, {
          x: 1, y: 2, w: 8, h: 2,
          fontSize: 20,
          fontFace: this.theme.typography.bodyFont,
          color: this.theme.colors.text,
          align: 'center',
          valign: 'middle'
        });
        break;

      case 'content':
        slide.addText(slideContent.content, {
          x: 0.5, y: 1.5, w: 9, h: 3.5,
          fontSize: 16,
          fontFace: this.theme.typography.bodyFont,
          color: this.theme.colors.text,
          wrap: true
        });
        break;

      case 'image':
        if (slideContent.imageUrl) {
          try {
            slide.addImage({
              path: slideContent.imageUrl,
              x: 2, y: 2, w: 6, h: 3
            });
          } catch (error) {
            // Fallback to placeholder if image fails
            this.addImagePlaceholder(slide);
          }
        } else {
          this.addImagePlaceholder(slide);
        }
        break;

      default:
        slide.addText(slideContent.content, {
          x: 0.5, y: 1.5, w: 9, h: 3.5,
          fontSize: 16,
          fontFace: this.theme.typography.bodyFont,
          color: this.theme.colors.text,
          wrap: true
        });
    }
  }

  private addImagePlaceholder(slide: any) {
    slide.addShape(this.pptx.ShapeType.rect, {
      x: 2, y: 2, w: 6, h: 3,
      fill: { color: this.theme.colors.surface },
      line: { color: this.theme.colors.primary, width: 2, dashType: 'dash' }
    });

    slide.addText('IMAGE PLACEHOLDER', {
      x: 2, y: 3.2, w: 6, h: 0.6,
      fontSize: 16,
      fontFace: this.theme.typography.headingFont,
      color: this.theme.colors.primary,
      align: 'center',
      bold: true
    });
  }
}
